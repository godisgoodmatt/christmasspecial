Name,Displayed As,Symbol,Description,Stacks?,Remove at End Turn?,Remove at Start Turn?,Invisible?,Blocked by Reduce?,Script: When inflicted,Script: On any status infliction,Script: Before Start Turn,Script: On Start Turn,Script: On any equipment use,Script: On any countdown reduce,Script: End Turn,Script: After Combat,Script: On damage inflicted,Script: On damage taken,Script: On status remove
Slush,Slush,shiver,All [ice] ice damage is cut in half,YES,NO,NO,NO,NO,,,,,,,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Slush\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,if(dmgtype == ICE) { attack(-dmg / 2); },,
Damageup,Power Boost,sword,Do [sword]<value> extra damage with each attack this turn.,YES,YES,NO,NO,NO,,,,,,,,,target.hp -= getstatusself(~Damageup~); target.textparticle(~[red]+~+getstatusself(~Damageup~));,,
Permaboost,Perma Boost,sword,Do [sword]<value> extra damage with each attack this battle.,YES,NO,NO,NO,NO,,,,,,,,,target.hp -= getstatusself(~Permaboost~); target.textparticle(~[red]+~+getstatusself(~Permaboost~));,,
Regen,Regen,regen,Heal by [heal]<value> for every attack this turn,YES,YES,NO,NO,NO,,,,,attackself(-getstatusself(~Regen~)); sfx(~_heal~);,,,,,,
ShieldEater,ShieldEater,shieldeater,Constantly destroys half of current shield,YES,NO,NO,NO,NO,,,,,,,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~ShieldEater\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move(); attackself(getstatusself(SHIELD) / 2); sfxdamage(target[;] d); sfx(~_shield~);,,,,
Bleed,Bleed,bleed,Take [red]<value> [white]damage when using any equipment.|Pierces shields,YES,YES,NO,NO,NO,,,,,pierceattackself(getstatusself(~Bleed~)); sfx(~_poison~); sfxdamage(target[;] d); self.textparticle(~[red]Bleeding out!~);,,,,,,
Dodgey,Dodgey,dodge,All attacks have a 50% chance to deal 50% less damage,YES,NO,NO,NO,NO,,,,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Dodgey\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,if(chance(50)){ self.hp += (dmg/2); sfx(~_dodge~); self.textparticle(~[yellow]DODGED!~); },
Stun,Stun,stun,<value> equipment is disabled this turn,YES,YES,NO,NO,NO,var goodeq = []; for(eq in self.equipment){ if(eq.availablethisturn){ goodeq.push(eq); }; }; goodeq = shuffle(goodeq); var s = getstatusself(~Stun~); while(goodeq.length > 0 && s > 0){ s-=1; var r = goodeq.pop(); r.availablethisturn = false; r.unavailabledetails = [~Stunned~]; r.animate(~flashandshake~); }; sfx(~_shock~);,,,var goodeq = []; for(eq in self.equipment){ if(eq.availablethisturn){ goodeq.push(eq); }; }; goodeq = shuffle(goodeq); var s = getstatusself(~Stun~); while(goodeq.length > 0 && s > 0){ s-=1; var r = goodeq.pop(); r.availablethisturn = false; r.unavailabledetails = [~Stunned~]; r.animate(~flashandshake~); }; sfx(~_shock~);,,,,,,,
Drowning,Drowning,potion,Take 1 damage for every countdown reduce and equipment used,NO,NO,NO,NO,NO,,,,,pierceattackself(1); sfx(~_poison~); sfxdamage(target[;] d); self.textparticle(~[blue]DROWNING!~);,pierceattackself(1); sfx(~_poison~); sfxdamage(target[;] d); self.textparticle(~[blue]DROWNING!~);,,,,,
Perma Reduce,Prema_Reduce,reduce,Take less damage from every attack this battle.,YES,NO,NO,NO,NO,inflictself(REDUCE[;] status.value); sfx(~_shield~);,,,inflictself(REDUCE[;] status.value); sfx(~_shield~);,,,,,,,
Blighted,[purple]Blighted,vanish,[purple]Has 30% chance to give [dodge]1 [purple]to enemy on equipment use|[purple]Has 20% chance to deal 3 damage on equipment use,NO,YES,NO,NO,NO,,,,,if(chance(30)){ inflict(~DODGE~[;] 1); sfx(~_shock~); } if(chance(20)){ pierceattackself(3); sfxdamage(target[;] 3); },,,,,,
regeneration,Regeneration,grace,Heal [heal]<value> health at the start of turn.,YES,NO,NO,NO,NO,,,,attackself(-getstatusself(~regeneration~)); sfx(~_heal~); var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Regeneration\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,,
Powerdown,Power_Down,powerdown,Do [sword]<value> less damage with each attack this turn.|If attacks deal less damage than power down heal enemy with the difference,YES,YES,NO,NO,NO,,,,,,,,,target.hp += getstatusself(~Powerdown~); target.textparticle(~[red]-~-getstatusself(~Powerdown~));,,
Permadown,Perma_Down,powerdown,Do [sword]<value> less damage with each attack this turn.|If attacks deal less damage than power down heal enemy with the difference|Max of 4,YES,NO,NO,NO,NO,if(getstatusself(~Permadown~) >= 4) { removestatusself(~Permadown~[;] getstatusself(~Permadown~) - 4); },,if(getstatusself(~Permadown~) >= 4) { removestatusself(~Permadown~[;] getstatusself(~Permadown~) - 4); },,,,,,target.hp += getstatusself(~Permadown~); target.textparticle(~[red]-~-getstatusself(~Permadown~));,,
Lastingpower,Lasting_Power,sword,Do [sword]<value> extra damage with each attack this turn.|,YES,NO,NO,NO,NO,,,,,,,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Lastingpower\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,target.hp -= getstatusself(~Lastingpower~); target.textparticle(~[red]-~+getstatusself(~Lastingpower~));,,
alternate_Blighted,Blighted?,vanish,[purple]Has 35% chance to deal 3 damage to you next turn on item use|[purple]Has 10% chance to stun you next turn on item use,NO,YES,NO,NO,NO,,,,,if(chance(10)){ jinx(~Blighted? Stun~[;]~Get stunned~[;]~Get stunned~[;]~inflict(\~Stun\~[;]%VAR%); sfx(\~_shock\~);~[;]self[;]self[;]1[;](7)); sfx(~_thinghappens~); } if(chance(35)){ jinx(~Blighted? Damage~[;]~Take [sword]%VAR%~[;]~Take [sword]%VAR%~[;]~pierceattack(%VAR%); sfxdamage(null[;]%VAR%);~[;]self[;]self[;]1[;](3)); sfx(~_thinghappens~); },,,,,,
alternate_Bleed,Bleed?,bleed,Take [red]1 [white]damage when reducing countdowns|Pierces shields,NO,YES,NO,NO,NO,,,,,,pierceattackself(1); sfx(~_poison~); sfxdamage(target[;] 1); self.textparticle(~[red]Bleeding out!~);,,,,,
alternate_regeneration,Regeneration?,grace,Next turn heal [grace]<value> health,YES,YES,NO,NO,NO,,,,,,,jinx(~Regeneration~[;]~Heal [grace]%VAR% health~[;]~Heal [grace]%VAR% health~[;]~attack(-%VAR%); sfx(\~_heal\~);~[;]self[;]self[;]1[;](getstatusself(~alternate_regeneration~))); sfx(~_thinghappens~);,,,,
Parry,Parry,nerfed,Next attack has status effects and damage reflected to the attacker|Removes 1 parry when attacked,YES,NO,NO,NO,NO,,if (self.getvar(~enemyturn~)) { jinx(~Parried Effect~[;]~Effect from [nerfed]Parry~[;]~Effect from [nerfed]Parry~[;]~inflict(\~~+inflicted_type+~\~[;]~+inflicted_value+~); sfx(\~_thinghappens\~);~[;]target[;]self[;]1[;]1); sfx(~_thinghappens~); },,self.resetvar(~enemyturn~);,,,self.setvar(~enemyturn~[;] true);,,,if (self.getvar(~enemyturn~)) { if(dmg > 0) { attack(dmg[;]dmgtype); } } var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Parry\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,
Fan,Fan,fan,Can't be burned when having this effect|Fire damage is also cut in half|Decreases by 1 each turn,YES,NO,NO,NO,NO,,,removestatusself(FIRE[;] ALL);,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Fan\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,if(dmgtype == FIRE) { attackself(-dmg / 2); },
Karen Rule,Karen_Rule,dynamo,Whoopsie something mustve not been plugged in right :D,NO,NO,NO,YES,NO,,,if(self.spaceleft() >= 2){ giveequipment(rand(getequipmentlist(null[;][][;][~alternateversion~[;]~skillcard~[;]~excludefromrandomlists~[;]~robotonly~[;]~witchonly~]))[;] -1); },,,,,,,,
Tree,Tree,thorns,SHHHHHHHHHHHHHHHHHHHH|Your not seeing this,NO,NO,NO,YES,NO,,,,,,,,,,if(self.spaceleft() >= 1){ giveequipment([~Ornament~][;]true[;]false); },
Song,Song,song,Show 'em your power thru the form of|SOOOOOOONNNNNGGGGG,YES,NO,NO,NO,NO,,,,,,,var s = new elements.Skill(~Against all odds_old~); s.script=~removestatusself(\~Song\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move(); ,,,,
Too Sweet,Too_Sweet,heart,All damage dealt this turn is cut by half|Share all status effects with enemy|When either happens removes 1 status,YES,YES,NO,NO,NO,,jinx(~Parried Effect~[;]~Effect from [nerfed]Parry~[;]~Effect from [nerfed]Parry~[;]~inflict(\~~+inflicted_type+~\~[;]~+inflicted_value+~); sfx(\~_thinghappens\~);~[;]target[;]self[;]1[;]1); sfx(~_thinghappens~); var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Too Sweet\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,,attack(-dmg / 2); var s = new elements.Skill(~Against all odds_old~); s.script=~removestatusself(\~Too Sweet\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,
Sting,Sting,sting,Damage to target is increased by 50%|Every time attacked loses 1 of this effect,YES,NO,NO,NO,NO,,,,,,,,,,attackself(dmg / 2); var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~Sting\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,
Whelm,shouldntsee,blind,,NO,YES,NO,YES,NO,,,,Gadget.changegadget(self[;] ~Whelm (0 Uses)~[;] ~Whelm (2 Uses)~);,,,,,,,
moderatewhelm,Moderatewhelmed,sword,Moderatewhelm deals <value> more damage.,YES,NO,NO,NO,NO,,,,,,,,,,,
ncr_lightswitch1,Light_Switch_1,dice,Roll an extra 1 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch2,Light_Switch_2,dice,Roll an extra 2 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch3,Light_Switch_3,dice,Roll an extra 3 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch4,Light_Switch_4,dice,Roll an extra 4 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch5,Light_Switch_5,dice,Roll an extra 5 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
ncr_lightswitch6,Light_Switch_6,dice,Roll an extra 6 next turn.,NO,NO,YES,NO,NO,,,,,,,,,,,
Demise,Timely_Demise,skipturn,While you have this status[;] lose [heart]1 health when using any equipment.|Status amount decreases by 1 per turn.,YES,NO,NO,NO,NO,,,,,pierceattackself(1); sfxdamage(self|1);,,var s = new elements.Skill(~Against all odds_old~); s.script=~removestatusself(\~Demise\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0.01[;]null); tw.onComplete(s.execute[;][self[;]target]); tw.move();,,,,
winterwitch,Invisible,,Take 1 damage every 2 seconds,NO,NO,NO,YES,NO,,,,self.resetvar(~winterwitchact~); var s = new elements.Skill(~Against all odds_old~); s.script = ~if(self.dicepool.length == 0 # self.doendturnnow # self.hp == 0) { self.getvar(\~winterwitchact\~).stop(); } else { pierceattackself(1); sfxdamage(self[;] 1); }~; var act = new motion.actuators.SimpleActuator(null[;] 2[;] null); act._repeat = -1; self.setvar(~winterwitchact~[;] act); act.onRepeat(s.execute[;] [self[;]target]); act.move();,,,if(self.varexists(~winterwitchact~)) { self.getvar(~winterwitchact~).stop(); self.resetvar(~winterwitchact~); },if(self.varexists(~winterwitchact~)) { self.getvar(~winterwitchact~).stop(); self.resetvar(~winterwitchact~); },,,
threshold,Threshold,threshold,You can't do more than <value> moves this turn.,YES,YES,NO,NO,NO,Rules.movelimit = status.value;,,,,,,Rules.movelimit = 0;,Rules.movelimit = 0;,,,
cursesuppressor,Curse Suppressor,curse,Odds of [curse]Curse triggering equal to 25%|this turn,NO,YES,YES,NO,NO,Rules.curseodds = 25;,,,,,,Rules.curseodds = 50;,,,,
cursebooster,Curse Booster,curse,Odds of [curse]Curse triggering equal to 100%|this turn,NO,YES,NO,NO,NO,,,Rules.curseodds = 100;,,,,Rules.curseodds = 50;,,,,
heater,Heater,weaken,Weaken all equipment with [ice] symbol.,NO,YES,NO,NO,NO,,,,var eqtoweaken = []; for (eq in self.equipment){ if(eq.availablethisturn && eq.fulldescription.indexOf(~[ice]~) != -1 && !eq.hastag(~weakenavoid~) && !eq.hastag(~weakenimmune~)){ eqtoweaken.push(eq); } } for(eq in eqtoweaken) eq.animate(WEAKEN);,,,,,,,
heater+,Heater+,weaken,Weaken all [blue]cyan[] equipment.,NO,YES,NO,NO,NO,,,,var eqtoweaken = []; for (eq in self.equipment){ if(eq.availablethisturn && eq.equipmentcol == 8 && !eq.hastag(~weakenavoid~) && !eq.hastag(~weakenimmune~)){ eqtoweaken.push(eq); } } for(eq in eqtoweaken) eq.animate(WEAKEN);,,,,,,,
never6,Never_roll_6,dice,You can't roll 6 this fight.,NO,NO,NO,NO,NO,var dicerange = []; if(self.isplayer)  dicerange = Rules.actualplayerdicerange.copy(); else  dicerange = Rules.actualenemydicerange.copy(); if(dicerange.length == 0) { dicerange = [1[;]2[;]3[;]4[;]5[;]6]; } dicerange.remove(6); if(dicerange.length == 0) { dicerange = [1]; } if(self.isplayer)  Rules.playerdicerange(dicerange); else  Rules.enemydicerange(dicerange);,,,,,,,if(self.isplayer) { Rules.playerdicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); } else { Rules.enemydicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); },,,
never5,Never_roll_5,dice,You can't roll 5 this fight.,NO,NO,NO,NO,NO,var dicerange = []; if(self.isplayer)  dicerange = Rules.actualplayerdicerange.copy(); else  dicerange = Rules.actualenemydicerange.copy(); if(dicerange.length == 0) { dicerange = [1[;]2[;]3[;]4[;]5[;]6]; } dicerange.remove(5); if(dicerange.length == 0) { dicerange = [1]; } if(self.isplayer)  Rules.playerdicerange(dicerange); else  Rules.enemydicerange(dicerange);,,,,,,,if(self.isplayer) { Rules.playerdicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); } else { Rules.enemydicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); },,,
never4,Never_roll_4,dice,You can't roll 4 this fight.,NO,NO,NO,NO,NO,var dicerange = []; if(self.isplayer)  dicerange = Rules.actualplayerdicerange.copy(); else  dicerange = Rules.actualenemydicerange.copy(); if(dicerange.length == 0) { dicerange = [1[;]2[;]3[;]4[;]5[;]6]; } dicerange.remove(4); if(dicerange.length == 0) { dicerange = [1]; } if(self.isplayer)  Rules.playerdicerange(dicerange); else  Rules.enemydicerange(dicerange);,,,,,,,if(self.isplayer) { Rules.playerdicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); } else { Rules.enemydicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); },,,
never3,Never_roll_3,dice,You can't roll 3 this fight.,NO,NO,NO,NO,NO,var dicerange = []; if(self.isplayer)  dicerange = Rules.actualplayerdicerange.copy(); else  dicerange = Rules.actualenemydicerange.copy(); if(dicerange.length == 0) { dicerange = [1[;]2[;]3[;]4[;]5[;]6]; } dicerange.remove(3); if(dicerange.length == 0) { dicerange = [1]; } if(self.isplayer)  Rules.playerdicerange(dicerange); else  Rules.enemydicerange(dicerange);,,,,,,,if(self.isplayer) { Rules.playerdicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); } else { Rules.enemydicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); },,,
never2,Never_roll_2,dice,You can't roll 2 this fight.,NO,NO,NO,NO,NO,var dicerange = []; if(self.isplayer)  dicerange = Rules.actualplayerdicerange.copy(); else  dicerange = Rules.actualenemydicerange.copy(); if(dicerange.length == 0) { dicerange = [1[;]2[;]3[;]4[;]5[;]6]; } dicerange.remove(2); if(dicerange.length == 0) { dicerange = [1]; } if(self.isplayer)  Rules.playerdicerange(dicerange); else  Rules.enemydicerange(dicerange);,,,,,,,if(self.isplayer) { Rules.playerdicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); } else { Rules.enemydicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); },,,
never1,Never_roll_1,dice,You can't roll 1 this fight.,NO,NO,NO,NO,NO,var dicerange = []; if(self.isplayer)  dicerange = Rules.actualplayerdicerange.copy(); else  dicerange = Rules.actualenemydicerange.copy(); if(dicerange.length == 0) { dicerange = [1[;]2[;]3[;]4[;]5[;]6]; } dicerange.remove(1); if(dicerange.length == 0) { dicerange = [1]; } if(self.isplayer)  Rules.playerdicerange(dicerange); else  Rules.enemydicerange(dicerange);,,,,,,,if(self.isplayer) { Rules.playerdicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); } else { Rules.enemydicerange([1[;] 2[;] 3[;] 4[;] 5[;] 6]); },,,
fireplace,Fireplace,heal,When you are hit by fire[;] it will heal you instead of damage this turn.,NO,YES,NO,NO,NO,self.innate.remove(~absorbfire~); self.innate.push(~absorbfire~);,,,,,,self.innate.remove(~absorbfire~);,self.innate.remove(~absorbfire~);,,,
instanttransform,instanttransform,potion,(text should not appear),NO,YES,NO,YES,NO,beartransform();,,,,,,,,,,
bearcurse,Bear's_Curse,curse,Curse yourself each turn,NO,NO,NO,NO,NO,beartransform();,,,inflictself(CURSE); sfx(~_curse~[;]~~[;]0.2);,,,,,,,
creativecrisis,Creative_Crisis,cog,You make no new gadgets after this fight.|Your current gadgets will become Broken Gadgets.,NO,NO,NO,NO,NO,,,,,,,,Rules.inventor_inspiration = false; var skillList = []; for(skill in self.getskillcard().skills) { skillList.push(skill.name); } for(skill in skillList) { Gadget.changegadget(self[;] skill[;]~Broken Gadget~); },,,
consumerism,Consumerism,cog,You make <value> additional gadget(s) after this fight.,YES,NO,NO,NO,NO,,,,,,,,,,,
creativecrisis+,creativecrisis+,cog,(text should not appear),NO,NO,NO,NO,NO,,,,,,,,Rules.inventor_inspiration = false;,,,
reversecpu,Garbage Collector,cog,Next roll reduces CPU instead of increasing it.,YES,YES,NO,NO,NO,,,,,,,,,,,
robotfreeze,Frozen,ice,Turns the highest dice rolled into a 1.,YES,YES,NO,NO,NO,,,,,,,,,,,
oddcpureduce,Odd CPU Reduce,cog,You shouldn't be seeing this.,NO,YES,NO,YES,NO,,,,,,,,,,,
commandment,Commandment,heal,(should not appear),NO,YES,NO,YES,NO,var forbiddendice = self.getvar(~forbiddendice~); status.scriptonshockrelease = ~for (d in self.dicepool) if (d.consumed && self.getvar(\~forbiddendice\~)[1].indexOf(d.basevalue) != -1) {removestatusself(\~Commandment\~); break;}~,,,,var dice = e.assigneddice; if (e.tempreuseableequipment.length != 0) for (f in e.tempreuseableequipment) {dice = dice.concat(f.assigneddice);} for (d in dice) if (d != null && self.getvar(~forbiddendice~)[1].indexOf(d.basevalue) != -1) { removestatusself(~Commandment~); break; },if (self.getvar(~forbiddendice~)[1].indexOf(e.dicehistory[e.dicehistory.length-1].basevalue) != -1) removestatusself(~Commandment~);,if(target != null && target.hp > 0) { var s = new elements.Skill(~Against all odds_old~); s.script = self.getvar(~commandbonus~)[1]; s.execute(self[;]target); },,,,
grabbag,Grab_Bag,star,The items you currently have are from Grab Bag,NO,YES,NO,NO,NO,var s = new elements.Skill(~grabbag_internal~); s.execute(self[;]target);,,,,,,,,,,
morefluff,More_Fluff,dynamo,The items you currently have are from Jackeaa's More Fluff mod,NO,YES,NO,NO,NO,var s = new elements.Skill(~morefluff_internal~); s.execute(self[;]target);,,,,,,,,,,
rs,Reference_Stuff,grace,The items you have are from the Reference Stuff mod,NO,YES,NO,NO,NO,var s = new elements.Skill(~rs_internal~); s.execute(self[;]target);,,,,,,,,,,
fade,Fade,vanish,Duplicate dice are immediately destroyed. Disappears when triggered.,YES,YES,NO,NO,YES,,,,,,,,,,,
nothing,Nothing,nothing,Does absolutely nothing.,NO,YES,NO,NO,NO,,,,,,,,,,,
alternate_nothing,Nothing?,nothing,Doesn't do something.,NO,YES,NO,NO,NO,,,,,,,,,,,
Storm,Storm,graystorm,Do [sword]-<value> less damage with each attack this turn.|[purple]Has 35% chance to deal 3 damage to you next turn on item use|[purple]Has 10% chance to stun you next turn on item use,YES,YES,NO,NO,NO,,,,,if(chance(10)){ jinx(~Storm Stun~[;]~Get stunned~[;]~Get stunned~[;]~inflict(\~Stun\~[;]%VAR%); sfx(\~_shock\~);~[;]self[;]self[;]1[;](7)); sfx(~_thinghappens~); } if(chance(35)){ jinx(~Storm Damage~[;]~Take [sword]%VAR%~[;]~Take [sword]%VAR%~[;]~pierceattack(%VAR%); sfxdamage(null[;]%VAR%);~[;]self[;]self[;]1[;](3)); sfx(~_thinghappens~); },,,,target.hp += getstatusself(~Storm~); target.textparticle(~[red]-~-getstatusself(~Storm~));,,
redshift,Redshift,redshift,Shock all of your [red]red[] equipment.,NO,YES,NO,NO,YES,,,,runscript(~christmasspecial/redshift~[;][self]);,,,,,,,
endlesswinterfreeze,Endless Winter,endlesswinter,Gain [ice]<value> freeze each turn.,YES,NO,NO,NO,NO,inflictself(ICE); sfx(~_ice~);,,inflictself(ICE[;]status.value); sfx(~_ice~);,,,,,,,,
falseswipe,False_Swipe,recycle,(invisible - prevents enemy from dying to false swipe),YES,YES,YES,YES,NO,,,,,,,,,if(target.hp < status.value){ target.hp = status.value; } removestatusself(~falseswipe~[;]ALL);,,
losedice,-1_dice,dice6,Enemy has <value> less dice this turn,YES,YES,NO,NO,NO,,,self.extradice-=getstatusself(~losedice~);,,,,self.extradice+=getstatusself(~losedice~);,,,,
ncr_snap,Snap!,glove,Use a random equipment for free!|Applies immediately when inflicted[;] if possible[;]|or at the start of your turn.,YES,NO,NO,NO,NO,var snappableequipment = [for(eq in self.equipment) if(eq.onscreen() && eq.isready() && eq.skillcard == ~~ && eq.getslots().length > 0) eq]; var val = inflicted_value; var snapoccurred = false; if(snappableequipment.length > 0) shuffle(snappableequipment); while(val > 0) { if(snappableequipment.length == 0) break; runscript(~ncrmod/snap~|[snappableequipment.pop()|true|self|target]); val--; var tw = new motion.actuators.SimpleActuator(null|0.01|null); var s = new elements.Skill(~Against all odds_old~); s.script = ~  removestatusself(\~~ + status.type + ~\~);~; tw.onComplete(s.execute|[self|target]); tw.move(); snapoccurred = true; },,,var snappableequipment = [for(eq in self.equipment) if(eq.onscreen() && eq.isready() && eq.skillcard == ~~ && eq.getslots().length > 0) eq]; var val = status.value; var snapoccurred = false; if(snappableequipment.length > 0) shuffle(snappableequipment); while(val > 0) { if(snappableequipment.length == 0) break; runscript(~ncrmod/snap~|[snappableequipment.pop()|true|self|target]); val--; removestatusself(status.type); snapoccurred = true; } if(snapoccurred) sfx(~jester_snap~);,,,,,,,
ncr_error,Error,ncr_error,At the start of your turn[;] a random item errors out[;]|rendering it unusable for that turn.,YES,YES,NO,NO,YES,if(self.dicepool.length > 0) { var erroramt = inflicted_value; var erroreq = []; var optimalerroreq = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.hastag(~errorimmune~) == false && eq.skillcard == ~~ && eq.isready()) { erroreq.push(eq); optimalerroreq.push(eq); /*don't avoid erroring shocked equipment if error inflicted midturn*/ } } while(erroramt > 0) { var pickedeq = null; if(optimalerroreq.length > 0) pickedeq = rand(optimalerroreq); else pickedeq = rand(erroreq); pickedeq.removedice(); roboterror(self[;][pickedeq]); optimalerroreq.remove(pickedeq); erroreq.remove(pickedeq); if(erroreq.length < 1) break; erroramt--; } if (self.layout == ~DECK~) { Deck.advance(0.8); } } },,,var erroramt = status.value; var erroreq = []; var optimalerroreq = []; if(self.equipment.length > 0) { for(eq in self.equipment) { if(eq.hastag(~errorimmune~) == false && eq.skillcard == ~~ && eq.isready()) { erroreq.push(eq); if(!eq.weakened && eq.shockedsetting == 0) optimalerroreq.push(eq); } } while(erroramt > 0) { var pickedeq = null; if(optimalerroreq.length > 0) pickedeq = rand(optimalerroreq); else pickedeq = rand(erroreq); pickedeq.removedice(); roboterror(self[;][pickedeq]); optimalerroreq.remove(pickedeq); erroreq.remove(pickedeq); if(erroreq.length < 1) break; erroramt--; } if (self.layout == ~DECK~) { Deck.advance(0.8); } },,,,,,,
ncr_error_all,Error_all,ncr_error,All of your items error out[;] rendering them unusable for this turn.,NO,YES,NO,NO,YES,if(self.dicepool.length > 0) { roboterror(self); self.roll_error = true; if (self.layout == ~DECK~) { Deck.advance(0.8); } },,,roboterror(self); if (self.layout == ~DECK~) { self.roll_error = true; Deck.advance(0.8); },,,,,,,
reversenexttarget,Swap_Next_Target,recycle,The next equipment you use will swap target.,YES,YES,NO,NO,NO,,,,,,,,,,,
mf_stun,Stun,stun,Random equipment is disabled for the turn.,YES,YES,NO,NO,YES,,,,var goodeq = []; for(eq in self.equipment){ if(eq.availablethisturn){ goodeq.push(eq); }; }; goodeq = shuffle(goodeq); var s = getstatusself(~mf_stun~); while(goodeq.length > 0 && s > 0){ s-=1; var r = goodeq.pop(); r.availablethisturn = false; r.unavailabledetails = [~Stunned~]; r.animate(~flashandshake~); }; sfx(~_shock~);,,,,,,,
batted,Battered,dice,Enemy caught the dice you batted!|They get <value> more dice next turn.,YES,YES,NO,NO,NO,,,,,,,,,,,
healaftercombat,Regeneration,heal,After combat[;] recover [heal]<value> health.|Doesn't trigger if you flee.,YES,NO,NO,NO,NO,,,,,,,,if(!flee){ attackself(-getstatusself(~healaftercombat~)); };,,,
watchburstbeam,WatchBurstBeam,dice,(should not appear),NO,YES,NO,YES,NO,self.setvar(~burstbeamdamage~[;]self.limitvalue);,,,,self.setvar(~burstbeamdamage~[;]self.limitvalue);,,,,,self.setvar(~burstbeamdamage~[;]self.limitvalue);,
all6,nunya,dice6,shhhh secwet,NO,NO,NO,YES,NO,,,,var c = 0; for (mydice in self.dicepool){ if (mydice.available()){ mydice.animatereroll(6[;] self.screenposition()[;] c * 0.05); c++; } } sfx(~entercombat_ladyluck_phase2~); var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~all6\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,,
mf_healnextturn,Heal_Next_Turn,heart,At the start of next turn[;] recover [heart]<value> health.,YES,NO,YES,NO,NO,,,,,,,,,,,attackself(-status.value); sfx(~_heal~);
snowball,Snowball_Effect,ice,Everytime you deal ice damage deal +1 more ice damage,NO,NO,NO,NO,NO,,,,,,,,,,,
snowballenemy,Snowball_Effect,ice,Everytime you deal ice damage deal +1 more ice damage,NO,NO,NO,YES,NO,status.scriptmodifydamage=~if(dmgtype == \~ice\~){return (dmg + 1);} else return (dmg);~,,,,,,,,,,
itemusetracker,itemusetracker,,text should not appear,NO,NO,NO,YES,NO,self.setvar(~recurringlists~[;][]);,,,,var itemuselist = self.getvar(~recurringlists~); for(eq in self.equipment){ if(eq.name == ~Recurring Winds~){ if(!e.hastag(~cannotreuse~) && e.name != ~Recurring Winds~){ itemuselist.push(e); break; } } } self.setvar(~recurringlists~[;]itemuselist);,,,self.setvar(~recurringlists~[;][]);,,,
manakeep,Keep_Next_Mana,potion,The next time you spend [mana] mana[comma] you will do it for free.,YES,NO,NO,NO,NO,self.setvar(~manakeepcounter~[;]getstatusself(MANA));,if(getstatusself(MANA) > self.getvar(~manakeepcounter~)){ self.setvar(~manakeepcounter~[;]getstatusself(MANA)); },,,if(e.script.indexOf('removestatusself(MANA') > 0){ if(getstatusself(MANA) < self.getvar(~manakeepcounter~)){ inflictself(MANA[;]self.getvar(~manakeepcounter~) - getstatusself(MANA)); var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~manakeep\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0.1[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move(); } },,,,,,
manaboost,Mana_Boost,potion,Gain [mana]<value> more mana when gain mana this turn.,YES,YES,NO,NO,NO,self.setvar(~manaboostcounter~[;]getstatusself(MANA));,if(getstatusself(MANA) > self.getvar(~manakeepcounter~)){ inflictself(MANA[;]getstatusself(~manaboost~)); self.setvar(~manakeepcounter~[;]getstatusself(MANA)); },,,,,,,,,
manakeep+,Keep_Next_Mana+,potion,The next time you spend [mana] mana[comma] it will increase your mana.,YES,NO,NO,NO,NO,self.setvar(~manakeeppluscounter~[;]getstatusself(MANA)); self.setvar(~whoachill~[;]1),if(getstatusself(MANA) > self.getvar(~manakeeppluscounter~)){ self.setvar(~manakeeppluscounter~[;]getstatusself(MANA)); },,,if(self.getvar(~whoachill~) == 1){ self.setvar(~whoachill~[;]0); [;] } else if(e.script.indexOf('removestatusself(MANA') > 0){ if(getstatusself(MANA) < self.getvar(~manakeeppluscounter~)){ inflictself(MANA[;](self.getvar(~manakeeppluscounter~) - getstatusself(MANA))*2); var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~manakeep+\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0.1[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move(); self.setvar(~statuschill~[;]0); } } },,,,,,
freetrades,Free_Trades,potion,All mana-using bonuses are free for this turn.,YES,YES,NO,NO,NO,self.setvar(~manakeepcounter~[;]getstatusself(MANA));,if(getstatusself(MANA) > self.getvar(~manakeepcounter~)){ self.setvar(~manakeepcounter~[;]getstatusself(MANA)); },,,if(e.script.indexOf('removestatusself(MANA') > 0){ if(getstatusself(MANA) < self.getvar(~manakeepcounter~)){ inflictself(MANA[;]self.getvar(~manakeepcounter~) - getstatusself(MANA)); var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~manakeep\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0.1[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move(); } },,,,,,
upgradecast,Upgrade_Cast,confuse,Upgrade the next spell you cast (does not triggers when you cast in upgraded slot.),YES,NO,NO,NO,NO,if(self.varexists(~upgradecastactuator~)) { self.getvar(~upgradecastactuator~).stop(); } for(eq in self.equipment){ eq.setvar(~upgradecast~[;]1); } var s = new elements.Skill(~Against All Odds_old~); s.script=~for(eq in self.equipment){if(!eq.upgraded && self.hasstatus(\~upgradecast\~) && !eq.weakened && eq.getvar(\~upgradecast\~) != 1 && eq.name != \~Next Tome\~){ var eqx = eq.x;var eqy = eq.y; eq.create(eq.name +\~+\~);eq.y = eqy;eq.x = eqx;eq.animate(\~flashandshake\~); sfx(\~upgradeequipment\~); removestatusself(\~upgradecast\~[;] 1);}};~; self.setvar(~upgradecastactuator~[;]new motion.actuators.SimpleActuator(null[;]0.1[;]null)); self.getvar(~upgradecastactuator~)._repeat = -1; self.getvar(~upgradecastactuator~).onRepeat(s.execute[;][self[;]target]); self.getvar(~upgradecastactuator~).move();,,,,,,,self.getvar(~upgradecastactuator~)._repeat = 0; self.resetvar(~upgradecastactuator~); self.resetvar(~upgradecastx~); self.resetvar(~upgradecasty~);,,,self.getvar(~upgradecastactuator~)._repeat = 0; self.resetvar(~upgradecastactuator~); self.resetvar(~upgradecastx~); self.resetvar(~upgradecasty~);for(eq in self.equipment) eq.resetvar(~upgradecast~);
weakencast,Weaken_Cast,weaken,Weaken the next spell you cast this turn,YES,YES,NO,NO,NO,if(self.varexists(~weakencastactuator~)) { self.getvar(~weakencastactuator~).stop(); } for(eq in self.equipment){ eq.setvar(~weakencast~[;]1); } var s = new elements.Skill(~Against All Odds_old~); s.script=~for(eq in self.equipment){if(self.hasstatus(\~weakencast\~) && !eq.weakened && eq.getvar(\~weakencast\~) != 1 && eq.name != \~Next Tome\~){ var eqx = eq.x;var eqy = eq.y;eq.animate(WEAKEN);eq.x = eqx;eq.y = eqy;self.resetvar(\~weakencastx\~);self.resetvar(\~weakencasty\~);removestatusself(\~weakencast\~[;] 1);eq.setvar(\~weakencast\~[;]1);}};~; self.setvar(~weakencastactuator~[;]new motion.actuators.SimpleActuator(null[;]0.1[;]null)); self.getvar(~weakencastactuator~)._repeat = -1; self.getvar(~weakencastactuator~).onRepeat(s.execute[;][self[;]target]); self.getvar(~weakencastactuator~).move();,,,,,,,self.getvar(~weakencastactuator~)._repeat = 0; self.resetvar(~weakencastactuator~); self.resetvar(~weakencastx~); self.resetvar(~weakencasty~);,,,self.getvar(~weakencastactuator~)._repeat = 0; self.resetvar(~weakencastactuator~); self.resetvar(~weakencastx~); self.resetvar(~weakencasty~);for(eq in self.equipment) eq.resetvar(~weakencast~);
shockcast,Shock_Cast,shock,Shock the next spell you cast this turn,YES,YES,NO,NO,NO,if(self.varexists(~shockcastactuator~)) { self.getvar(~shockcastactuator~).stop(); } for(eq in self.equipment){ eq.setvar(~shockcast~[;]1); } var s = new elements.Skill(~Against All Odds_old~); s.script=~for(eq in self.equipment){if(self.hasstatus(\~shockcast\~) && !eq.shocked && eq.getvar(\~shockcast\~) != 1 && eq.name != \~Next Tome\~){var eqx = eq.x;var eqy = eq.y;eq.animate(SHOCK);eq.x = eqx;eq.y = eqy;removestatusself(\~shockcast\~[;] 1);eq.setvar(\~shockcast\~[;]1);}};~; self.setvar(~shockcastactuator~[;]new motion.actuators.SimpleActuator(null[;]0.1[;]null)); self.getvar(~shockcastactuator~)._repeat = -1; self.getvar(~shockcastactuator~).onRepeat(s.execute[;][self[;]target]); self.getvar(~shockcastactuator~).move();,,,,,,,self.getvar(~shockcastactuator~)._repeat = 0; self.resetvar(~shockcastactuator~); self.resetvar(~shockcastx~); self.resetvar(~shockcasty~);,,,self.getvar(~shockcastactuator~)._repeat = 0; self.resetvar(~shockcastactuator~); self.resetvar(~shockcastx~); self.resetvar(~shockcasty~);for(eq in self.equipment) eq.resetvar(~shockcast~);
bookban1,Can't_Use_First_Spellbook,nospellbook,Reduces by 1 every turn. Unless it's zero[comma]|you can't use the first spellbook.,YES,NO,NO,NO,NO,self.setvar(~spellbook1unavailable~[;]status.value); self.getskillcard().unavailabledetails = [~Disabled (~+self.getvar(~spellbook1unavailable~)+~ turns left)~];,,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~bookban1\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0.1[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,,,
bookban2,Can't_Use_Second_Spellbook,nospellbook,Reduces by 1 every turn. Unless it's zero[comma]|you can't use the second spellbook.,YES,NO,NO,NO,NO,self.setvar(~spellbook2unavailable~[;]status.value); self.getskillcard().unavailabledetails = [~Disabled (~+self.getvar(~spellbook2unavailable~)+~ turns left)~];,,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~bookban2\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0.1[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,,,
bookban3,Can't_Use_Third_Spellbook,nospellbook,Reduces by 1 every turn. Unless it's zero[comma]|you can't use the third spellbook.,YES,NO,NO,NO,NO,self.setvar(~spellbook3unavailable~[;]status.value); self.getskillcard().unavailabledetails = [~Disabled (~+self.getvar(~spellbook3unavailable~)+~ turns left)~];,,var s = new elements.Skill(~Against All Odds_old~); s.script=~removestatusself(\~bookban3\~[;] 1);~; var tw = new motion.actuators.SimpleActuator(null[;]0.1[;]null); tw._repeat = 1; tw.onRepeat(s.execute[;][self[;]target]); tw.move();,,,,,,,,
nimblehandsstatus,nimblehandsstatus,,text should not appear,NO,NO,NO,YES,NO,if(self.gamevar.exists(~nimblehandsstolencard~)){ self.getvar(~nimblehandsstolencard~).availablethisturn = false; self.getvar(~nimblehandsstolencard~).unavailabletext = ~Borrowed~; self.getvar(~nimblehandsstolencard~).unavailabledetails = [~Say goodbye to Christmas!~[;]~Signed[;] {enemyname}~]; },,if(self.gamevar.exists(~nimblehandsstolencard~)){ self.getvar(~nimblehandsstolencard~).availablethisturn = false; self.getvar(~nimblehandsstolencard~).unavailabletext = ~Borrowed~; self.getvar(~nimblehandsstolencard~).unavailabledetails = [~Say goodbye to Christmas!~[;]~Signed[;] {enemyname}~]; },,,,if(self.gamevar.exists(~nimblehandsstolencard~)){ self.getvar(~nimblehandsstolencard~).availablenextturn = false; self.getvar(~nimblehandsstolencard~).unavailabletext = ~Borrowed~; self.getvar(~nimblehandsstolencard~).unavailabledetails = [~Say goodbye to Christmas!~[;]~Signed[;] {enemyname}~]; },if(self.hp > 0){ target.equipment.remove(self.getvar(~nimblehandsstolencard~)); },,,
fireweakness,Fire_Weakness,fireweakness,You are weak to [fire] fire.,NO,NO,NO,NO,NO,self.addinnate(~weakfire~);,,,,,,,self.innate.remove(~weakfire~);,,,
restore,Restore,heal,Heal [heal]<value> health at the end of your turn.,YES,YES,NO,NO,NO,,,,,,,if(target.hp > 0){attackself(-status.value); sfx(~_heal~); },,,,
ncr_lingeringshield,Lingering_shield,shield,Receive [shield]<value> shield every turn.,YES,NO,NO,NO,NO,,,inflictself(SHIELD|stat.value);,,,,,,,,
ncr_restraint_all,Restrain_all,weaken,Temporarily weaken a random equipment whenever you use a card|directed at the enemy. Equipment becomes less powerful.,NO,YES,NO,NO,YES,,,,,if(e.castdirection == 1) { inflictself(WEAKEN); self.applyequipmentcurses(); },,,,,,
eternitycannon,Eternity_Cannon,eternitycannon,Do [sword]5 damage at the start of each turn <value> time(s).,YES,NO,NO,NO,NO,,,,for(i in 0...status.value){ attack(5); }; sfxdamage(target[;]5*status.value);,,,,,,,
eternitycannondowngraded,Eternity_Cannon-,eternitycannon,Do [sword]3 damage at the start of each turn <value> time(s).,YES,NO,NO,NO,NO,,,,for(i in 0...status.value){ attack(3); }; sfxdamage(target[;]3*status.value);,,,,,,,
chain,chain,cog,text should not appear,NO,NO,NO,YES,NO,status.scriptoncursetrigger = ~runscript(\~christmasspecial/jester_dochaining\~[;][self])~; status.scriptonenemydodge = status.scriptoncursetrigger;,,,,,,,,,,\
mkapowcharge,Magic_Kapow_Charge,fury,Magic Kapow will deal double damage this turn.,NO,YES,NO,NO,NO,,,,,,,,,,,
shielddown,Shield_Down,potion,At the start of your turn[;] lose [shield]<value> shield.,YES,NO,NO,NO,YES,,,,removestatusself(SHIELD|status.value);,,,,,,,
rednote,Red_Note,rednote,Do [fire]<value> damage each turn|On even turns burn a dice|When removed deals [fire]5 damage burn all dice,YES,NO,NO,NO,NO,,,,,,,if(turn % 2 == 0){ inflict(FIRE); sfx(~_fire~); } attack(getstatusself(~rednote~)[;] FIRE); sfxdamage(target[;] getstatusself(~rednote~));,,,,attack(5[;] FIRE); sfxdamage(target[;] 5); inflict(FIRE[;] ALL); sfx(~_fire~);
greennote,Green_Note,greennote,Heal [heal]<value> health each turn|When removed remove all negative effects |and heal [heal]4 health,YES,NO,NO,NO,NO,,,,,,,attackself(-getstatusself(~greennote~)); sfx(~_heal~);,,,,var statuslist = [POISON[;]FIRE[;]SHOCK[;]ICE[;]WEAKEN[;]CURSE[;]BLIND[;]~Slush~[;]LOCK[;]~Bleed~[;]~Blighted~[;]~Too Sweet~[;]~Sting~[;]~Demise~[;]~reversenexttarget~[;]~Redshift~[;]~Storm~]; for(st in statuslist) { if(getstatus(st) > 0) { removestatusself(st[;] ALL); } if(getstatusself(st) > 0) { removestatusself(st[;] ALL); } } sfx(~_cure~); attackself(-4);
reennote,[red]Reen_[green]Note,reennote,[red]On_odd_turns[;]_[red]Do_[fire]<value>_dmg|[green]On_even_turns[;] [green]Heal_[heal]<value>_health|[red]When_removed[;][green]Heal_[heal]4_health [red]Do_[fire]4_dmg,YES,NO,NO,NO,NO,,,,,,,if(turn % 2 == 0){ attackself(-getstatusself(~reennote~)); sfx(~_heal~); } else { attack(getstatusself(~reennote~)[;] FIRE); sfxdamage(target[;] getstatusself(~reennote~)); },,,,sfx(~_cure~); attackself(-4); attack(4[;] FIRE); sfxdamage(target[;] 4);
yellownote,Yellow_Note,yellownote,Shock [shock]<value> items on odd turns|When removed do [shock]3 damage shock all items,YES,NO,NO,NO,NO,,,,,,,if(turn % 1 == 0){ inflict(SHOCK[;] getstatusself(~yellownote~)); sfx(~_shock~); },,,,inflict(SHOCK[;] ALL); sfx(~_shock~); attack(3[;] SHOCK); sfxdamage(target[;] 3);
orangenote,Orange_Note,orangenote,Weaken [weaken]<value> items on even turns|When removed Do [weaken]3 damage weaken 4 items,YES,NO,NO,NO,NO,,,,,,,if(turn % 2 == 0){ inflict(WEAKEN[;] getstatusself(~orangenote~)); sfx(~_weaken~); },,,,attack(3[;] WEAKEN); sfxdamage(target[;] 3); inflict(WEAKEN[;] 4); sfx(~_weaken~);
bownote,[yellow]Ra[green]in[blue]bo[purple]w_N[orange]ot[red]e,bownote,[yellow]Mimics [green]a [blue]random [purple]other [orange]notes [red]properties|[black]When [yellow]removed [green]gain [blue]a [purple]random [orange]note's [red]removal [black]effect,YES,NO,NO,NO,NO,,,,,,,var note = rand([~red~[;]~green~[;]~yellow~[;]~orange~[;]~blue~[;]~black~[;]~purple~]); if(note == ~red~){ attack(getstatusself(~bownote~)[;] FIRE); sfxdamage(target[;] getstatusself(~bownote~)); self.textparticle(~[red]Red Note~); } else if(note == ~green~){ attackself(-getstatusself(~bownote~)); sfx(~_heal~); self.textparticle(~[green]Green Note~); } else if(note == ~yellow~){ inflict(SHOCK[;] getstatusself(~bownote~)); sfx(~_shock~); self.textparticle(~[yellow]Yellow Note~); } else if(note == ~orange~){ inflict(WEAKEN[;] getstatusself(~bownote~)); sfx(~_weaken~); self.textparticle(~[orange]Orange Note~); } else if(note == ~black~){ attack(getstatusself(~bownote~)); sfxdamage(target[;] getstatusself(~bownote~)); self.textparticle(~[black]Black Note~); } else if(note == ~blue~){ inflict(ICE); sfx(~_ice~); self.textparticle(~[blue]Blue Note~); } else if(note == ~purple~){ inflict(POISON[;] getstatusself(~bownote~)); sfx(~_poison~); self.textparticle(~[purple]Purple Note~); },,,,var note = rand([~red~[;]~green~[;]~yellow~[;]~orange~[;]~blue~[;]~black~[;]~purple~]); if(note == ~red~){ attack(5[;] FIRE); sfxdamage(target[;] 5); inflict(FIRE[;] ALL); sfx(~_fire~); self.textparticle(~[red]Red Note~); } else if(note == ~green~){ sfx(~_cure~); attackself(-4); self.textparticle(~[green]Green Note~); } else if(note == ~yellow~){ inflict(SHOCK[;] ALL); sfx(~_shock~); attack(3[;] SHOCK); sfxdamage(target[;] 3); self.textparticle(~[yellow]Yellow Note~); } else if(note == ~orange~){ attack(3[;] WEAKEN); sfxdamage(target[;] 3); inflict(WEAKEN[;] 4); sfx(~_weaken~); self.textparticle(~[orange]Orange Note~); } else if(note == ~black~){ attack(6); sfxdamage(target[;] 6); self.textparticle(~[black]Black Note~); } else if(note == ~blue~){ inflict(ICE[;] ALL); sfx(~_ice~); self.textparticle(~[blue]Blue Note~); } else if(note == ~purple~){ inflict(POISON[;] 4); sfx(~_poison~); self.textparticle(~[pruple]Purple Note~); }
bluenote,Blue_Note,bluenote,Freeze a dice each turn|When removed freeze all dice,NO,NO,NO,NO,NO,,,,,,,inflict(ICE); sfx(~_ice~);,,,,inflict(ICE[;] ALL); sfx(~_ice~);
blacknote,Black_Note,blacknote,Do [sword]<value> damage|When removed Do [sword]6 damage,YES,NO,NO,NO,NO,,,,,,,attack(getstatusself(~blacknote~)); sfxdamage(target[;] getstatusself(~blacknote~));,,,,attack(6); sfxdamage(target[;] 6);
purpnote,Purple_Note,purplenote,Inflict [poison]<value> poison on odd turns|When removed inflict [poison]4 poison,YES,NO,NO,NO,NO,,,,,,,inflict(POISON[;] getstatusself(~purpnote~)); sfx(~_poison~);,,,,inflict(POISON[;] 4); sfx(~_poison~);
